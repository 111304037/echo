#version 100
uniform samplerCube cubeMap;
uniform samplerCube cubeMap1;
uniform mediump float roughness;
varying mediump vec4 color;
varying mediump vec3 normal;
varying mediump vec3 view_dir;
varying mediump vec3 world_pos;

mediump vec3 physicalBRDF( mediump vec3 n, mediump vec3 v, mediump vec3 l, mediump float gloss, mediump vec3 specularColor )
{
	return vec3( 1.0, 0.0, 0.1);
}



void main( )
{

	mediump vec4 surface_diffuse = vec4( 1.0, 1.0, 1.0, 1.0 );

	mediump vec3 light_dir = vec3(0, -1, -1);
	
//  float3 Nu = normalize(IN.LightingNormal);
  // for bump mapping, we will alter "Nu" to get "Nb"
  
 //  float3 Tu = normalize(IN.LightingTangent);
 // float3 Bu = normalize(IN.LightingBinorm);
 // float3 bumps = Bumpiness *
 //                  (tex2D(NormalMap, IN.TexCoord.xy).xyz - (0.5).xxx);
 // float3 Nb = Nu + (bumps.x * Tu + bumps.y * Bu);
 // Nb = normalize(Nb); // expressed in user-coord space
  
//   float3 Vu = normalize(IN.LightingEyeVec);
//  float vdn = dot(Vu, Nb); // or "Nu" if unbumped - see text

	mediump float vdnScale = 20.0;
	mediump float vdn = dot( normalize(view_dir), normalize(normal) );
	vdn = min(1.0, max(vdn, 0.0));
   // "fres" attenuates the strength of the reflection
  
   // according to Fresnel's law
  
  mediump float Kr = 3.0;// intensity of reflection
  mediump float KrMin = 0.7  * Kr;
  mediump float FresExp = 5.0;
  
	// QtANGLE D3DCompile failed, but dont know why ???
	// mediump float fres = KrMin + (Kr - KrMin) * pow((1.0 - abs(vdn)), FresExp);
	// fres = fres * 0.0000001 + 0.999999;
	mediump float fres = 1.0;
  mediump vec3 reflVect = normalize(reflect(normalize(view_dir), normalize(normal) )); // yes, normalize
  
   // now use the new intersection location as the 3D direction
    mediump vec4 reflColor = fres*textureCube(cubeMap, normalize(normal));
	mediump vec4 reflColor1 = fres*textureCube(cubeMap1, normalize(normal));
	reflColor = (1.0-roughness)*reflColor1 + roughness * reflColor;
 mediump vec4 SurfColor = vec4( 1.0, 1.0, 1.0, 1.0 );
 // mediump vec4 result = (SurfColor * reflColor);
 
  gl_FragColor = reflColor1 * surface_diffuse * 0.0000001*roughness + reflColor;
}


#if(0)
mediump vec3 PhysicalBRDF_X(mediump vec3 N, mediump vec3 V, mediump vec3 L, mediump float Gloss, mediump vec3 SpecCol)
{
	mediump vec3 H = normalize( V + L );
	
	// Compute perceptually linear roughness parameter (squared)
	mediump float m = pow( (1.0 - Gloss * 0.7), 6.0 );
	mediump float m2 = m * m;
	
	// Prevent highlights from getting too tiny since we don't have real area lights yet
	m2 = max( m2, 0.00001 );
	
	// GGX NDF
	mediump float NdotH = clamp( dot( N, H ), 0.0, 1.0 );
	mediump float spec = (NdotH * NdotH) * (m2 - 1.0) + 1.0;
	spec = m2 / (spec * spec);
	
	// Schlick-Smith Visibility Term
	mediump float k = (0.8 + m * 0.5) * (0.8 + m * 0.5) / 2;
	mediump float Gv = clamp( dot( N, V ), 0.0, 1.0 ) * (1.0 - k) + k;
	mediump float Gl = clamp( dot( N, L ), 0.0, 1.0 ) * (1.0 - k) + k;
	spec = spec/max( Gv * Gl, 1e-6 );
		
	// Schlick approximation for Fresnel
	mediump vec3 fresnel = lerp( SpecCol, 1.0, pow( 1.0 - dot(L, H), 5.0 ) );

	return (fresnel * spec) / 4.0;
}
#endif