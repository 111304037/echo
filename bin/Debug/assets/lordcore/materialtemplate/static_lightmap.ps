#version 100
precision mediump float;

#include <tonemapping.inc>
#include <fog_ps.inc>
#include <hdr_ldr.inc>

#ifdef EFFECT_COLOR
#include <effect_color.inc>
#endif

#define saturate(x) clamp( x, 0.0, 1.0 )

uniform mediump vec3  CameraDirection;
uniform mediump vec3  CameraPosition;
uniform mediump float CurrentTime;			// current time
uniform mediump float HighLight;

uniform sampler2D Albedo;
uniform mediump float DiffuseIntensity;

#ifdef DYNAMIC_SPECULAR
	uniform sampler2D 	  SpecularSampler;
	uniform mediump float SpecularIntensity;	// 0.0-16.f;
	uniform mediump float SpecularPow;			// 2.0,4.0,8.0,16.0,32.0;
#endif

varying mediump vec2 texCoord;
varying mediump vec3 normal;
varying mediump vec3 position;

#ifdef USE_LIGHTMAP
	uniform sampler2D LMSampler1;
	uniform mediump vec4 LMUV;
	uniform mediump vec3 LMScale1;
	varying mediump vec2 texCoord1;
#ifdef DOUBLE_LMP
	uniform sampler2D LMSampler2;
	uniform mediump vec4 LMUV2;
	uniform mediump vec3 LMScale2;
	uniform float LM1ToLM2;
#endif	
#endif

#ifdef UV_ROLLING
	uniform vec2 uRollingDir;
	uniform float uRollingSpeed;
#endif

#ifdef RECEIVE_FOG
	varying vec4 ofogColor;
#endif

#ifdef TRANSPARENT
	uniform mediump float AlphaValue;
#endif

#ifdef ALPHA_TEST
	uniform mediump float AlphaTestValue;
#endif

#ifdef COVERAGE_ALPHA
	uniform mediump vec3 coveragePos;
	uniform mediump float fallOff;
	uniform mediump float radius;
#endif

#ifdef ENV_MAP
	uniform sampler2D EnvSampler;
	uniform sampler2D EnvMaskSampler;
	uniform mediump float EnvStrength;
#endif

#define HSV_SUPPORT
#ifdef  HSV_SUPPORT
	#include <hsv.inc>
#endif

#ifdef SURFACE_COLOR_MASK
	uniform mediump vec3  HSVOffset1;
	uniform mediump vec3  HSVOffset2;
	uniform mediump vec3  HSVOffset3;
	uniform sampler2D 	  SurfaceColorMaskSampler;
#elif defined(SURFACE_COLOR)
	uniform mediump vec3  HSVOffset0;	
#endif

#ifdef SPECULAR_COLOR_MAP
	uniform mediump vec4 ActorLitParam[3]; // 0.sunDir  1.sunColor 2.environmentColor
	uniform sampler2D specularColorSampler;
	uniform mediump vec2 specularPower;
	uniform mediump vec4 uSpecularColor;
	uniform float uRadius;
	uniform float uFallOff;
	uniform vec3 coveragePos;
#endif

#ifdef NORMAL_MAP
	uniform sampler2D NormalSampler;
	varying mediump vec3 tangent;
	varying mediump vec3 binormal;
#endif

#ifdef FLOW_MAP
	uniform mediump vec2 FlowDir;
	uniform sampler2D 	 FlowSampler;
#endif

#define AMBIENT_LIGHT     1
#define DIRECTIONAL_LIGHT 2
#define POINT_LIGHT 	  3

uniform mediump int	 LightArrayInfo[8];
uniform mediump vec4 LightArrayData[16];

#ifdef FILTER_COLOR
uniform mediump vec4 filterColor;
uniform mediump float filterGray;
#endif

#ifdef RECEIVE_SHADOW
	uniform mediump float ShadowShade;
	uniform sampler2D 	  SMSampler;
	varying mediump vec4  shadowmapSpace;
	varying vec4 shadeVec;
#endif

#ifdef GROW
uniform sampler2D GrowMaskSampler;
uniform mediump float GrowAlpha;
#endif

// calculate diffuse
void LightingPhase( out mediump vec4 oLightSpecular, mediump vec4 iSpecularColor, mediump vec3 inPixelWorldPosition, mediump vec3 inPixelNormal, mediump float inSpecularIntensity, mediump float inSpecularPow)
{
	oLightSpecular= vec4( 0.0, 0.0, 0.0, 1.0);
	
	for( int i=0; i<2; i++)
	{
		int lightType = LightArrayInfo[i];
		mediump vec4 LightColor = LightArrayData[i*2];
		mediump vec4 LightDir   = LightArrayData[i*2+1];
		if( lightType==DIRECTIONAL_LIGHT)
		{
			// Specular
			mediump vec3 reflectNormal = normalize( reflect( LightDir.xyz, inPixelNormal));
			oLightSpecular.xyz += LightColor.xyz * pow( max( dot(reflectNormal, -CameraDirection), 0.0), inSpecularPow)* inSpecularIntensity;
		}
		else if( lightType==POINT_LIGHT)
		{
			mediump vec3  pixelToLight		  = LightDir.xyz-inPixelWorldPosition;
			mediump	float pixelToLightLen	  = length( pixelToLight);
			mediump float offsetDistance      = pixelToLightLen * LightDir.w;
			mediump float DistanceAttenuation = max( pow( 1.0-clamp( offsetDistance, 0.0, 1.0), LightColor.w), 0.0);
			
			// Specular
			mediump vec3 reflectNormal = normalize( reflect( -pixelToLight, inPixelNormal));
			oLightSpecular.xyz += LightColor.rgb  * DistanceAttenuation * pow( max( dot(reflectNormal, -CameraDirection), 0.0), inSpecularPow)* inSpecularIntensity;
		}
	}
	
	oLightSpecular *= iSpecularColor;
}

#ifdef EDGE_SHINE
	uniform mediump vec4  EdgeShineColor;
	uniform mediump float EdgeShinePower;
#endif

mediump vec3 SurfaceNormal(mediump vec3 n, mediump vec3 vTangent, mediump vec3 vBinormal)
{
   mediump vec3 T = vTangent;
   mediump vec3 B = vBinormal;
   mediump vec3 N = gl_FrontFacing ? normal : -normal;
   
   N = normalize(N);
   T -= dot(T, N)*N;
   T = normalize(T);
   B = (B - dot(B, N)*N) - dot(B, T)*T;
   B = normalize(B);

   n = 2.0*n - vec3(1.0);
   return normalize(T*n.x + B*n.y + N*n.z);
}

#ifdef ENV_MAP
vec3 computeEnvColor(vec3 en)
{
	en /= dot(vec3(1.0), abs(en));
	vec2 eH = abs(en.zx) - vec2(1.0, 1.0);
	vec2 eI = vec2(en.x < 0.0 ? eH.x : -eH.x, en.z < 0.0 ? eH.y : -eH.y);
	vec2 eJ = (en.y < 0.0) ? eI : en.xz; 
	eJ = vec2(0.5*(254.0 / 256.0), 0.125*0.5*(254.0 / 256.0))*eJ + vec2(0.5, 0.125*0.5);
	vec2 eL = vec2(eJ.x,eJ.y*8.0);
	vec4 eM = texture2D(EnvSampler, eL);
	vec3 r = eM.xyz;
	return r*r;
}
#endif

void main(void)
{
#ifdef GROW
mediump float grow = texture2D(GrowMaskSampler, texCoord1).r + GrowAlpha;
	if(grow < 1.)
	{
		discard;
	}	
#endif

#ifdef UV_ROLLING
	vec2 newTexCoord = texCoord + uRollingDir * CurrentTime * uRollingSpeed;
	mediump vec4 surfaceColor = texture2d_linear(Albedo, newTexCoord) * DiffuseIntensity;
#else
	// textureColor
	mediump vec4 surfaceColor = texture2d_linear(Albedo, texCoord) * DiffuseIntensity;
#endif
    
#ifdef ALPHA_TEST
    surfaceColor.a = step(0.5, surfaceColor.a);
#endif
	
#ifdef SURFACE_COLOR_MASK
	mediump vec3 surfaceColorMask = texture2D(SurfaceColorMaskSampler, texCoord).xyz;
	
	mediump vec3 hsvSurfaceColor = hsvAdjust(rgb2hsv(surfaceColor.xyz), HSVOffset1 * surfaceColorMask.x + HSVOffset2*surfaceColorMask.y + HSVOffset3*surfaceColorMask.z);
	surfaceColor.xyz = hsv2rgb(hsvSurfaceColor.xyz);
	
#elif defined(SURFACE_COLOR)
	mediump vec3 hsvSurfaceColor = hsvAdjust(rgb2hsv(surfaceColor.xyz), HSVOffset0);
	surfaceColor.xyz = hsv2rgb(hsvSurfaceColor.xyz);
#endif
	
	mediump vec3 finalNormal = normal;
	
#ifdef NORMAL_MAP
	// normal map
	// mediump vec3 texnormal = 2.0 * texture2D(NormalSampler, texCoord).xyz - vec3(1.0);
	// mediump vec3 binormal = normalize(cross(normal, tangent));
	// finalNormal = vec3(dot(vec3(tangent.x, binormal.x, normal.x), texnormal), dot(vec3(tangent.y, binormal.y, normal.y), texnormal), dot(vec3(tangent.z, binormal.z, normal.z), texnormal));

	finalNormal = SurfaceNormal(texture2D(NormalSampler, texCoord).xyz, tangent, binormal);
#endif

	
#ifdef FLOW_MAP
	mediump float flowRange = 1.0;
	mediump vec4  flowColor = texture2d_linear(FlowSampler, texCoord + FlowDir * CurrentTime * 0.001);
#endif
	
#ifdef DYNAMIC_SPECULAR
	// illumination
	mediump float specularIntensity = SpecularIntensity;
	mediump vec4 lightDiffuse  = vec4( 0.0, 0.0, 0.0, 1.0);
	mediump vec4 lightSpecular = vec4( 0.0, 0.0, 0.0, 1.0);
	mediump vec4 specularColor = texture2d_linear(SpecularSampler, texCoord);
	LightingPhase(lightSpecular, specularColor, position, finalNormal, specularIntensity, SpecularPow);
#else
	mediump vec4 lightDiffuse  = vec4( 0.0, 0.0, 0.0, 1.0);
	mediump vec4 lightSpecular = vec4( 0.0, 0.0, 0.0, 1.0);;
#endif
	
	vec4 specularColor1 = vec4(0.0, 0.0, 0.0, 1.0);
#ifdef SPECULAR_COLOR_MAP
	vec3 V = normalize(CameraPosition - position);
	float VdotC = dot(-V, CameraDirection);
	VdotC = pow(VdotC, uFallOff);
	vec4 textureColor = texture2d_linear(specularColorSampler, texCoord);
	vec3 L = normalize(ActorLitParam[0].xyz);
	vec3 H = normalize(L + V);
	float NdotH = saturate(dot(finalNormal, H));
	specularColor1.xyz = saturate(uSpecularColor.xyz * textureColor.xyz * specularPower.x * pow( NdotH, (specularPower.y * textureColor.w) ) * textureColor.w) * VdotC;
#endif

#ifdef RECEIVE_SHADOW
	// shadow
	mediump vec4  smColor = vec4(1.0, 1.0, 1.0, 1.0);
	mediump vec3  smCoordDepth = shadowmapSpace.xyz; 
	mediump vec2  smCoord;
	smCoord = smCoordDepth.xy * 0.5 + 0.5;
	mediump float dxx;
	mediump float dx = 1.0;
	//if(smCoord.x >= 1.0 || smCoord.y>=1.0 || smCoord.x<=0.0 || smCoord.y<=0.0)
	// 	dx = 1.0;
	//else
	//if(dot(shadeVec.xyz,normal)<0.0)
	{
		mediump float z = clamp(smCoordDepth.z, 0.0, 1.0);
 		dxx = dot(vec4(texture2D(SMSampler, smCoord)) ,vec4(1.0, 1.0 / 255.0, 1.0 / 65025.0, 1.0 / 16581375.0));
		dx = 2.71828 - exp(1024.0*(z-dxx));
	}
	dx = clamp(dx,ShadowShade,1.0);
	smColor = vec4(dx,dx,dx, 1.0);
#else
	mediump vec4 smColor = vec4(1.0, 1.0, 1.0, 1.0);
#endif

#ifdef USE_LIGHTMAP
	mediump vec3 LMColor1 = texture2d_linear(LMSampler1, texCoord1.xy*LMUV.zw+LMUV.xy).rgb * LMScale1;

	lightDiffuse.xyz = lightDiffuse.xyz * 0.0 + LMColor1;
	
#ifdef DOUBLE_LMP
	mediump vec3 LMColor2 = texture2d_linear(LMSampler2, texCoord1.xy*LMUV2.zw+LMUV2.xy).rgb * LMScale2;
	lightDiffuse.xyz = lightDiffuse.xyz * 0.0 + mix(LMColor1 ,LMColor2,LM1ToLM2);
#endif
#else
	lightDiffuse.xyz = vec3(1.0, 1.0, 1.0);
#endif

	mediump float diffuseGrayValue = dot( lightDiffuse.xyz, vec3(0.299, 0.587, 0.114));
	mediump float diffuseShodwMapmixRadio = clamp(diffuseGrayValue - smColor.x, 0.0, 1.0);

	lightDiffuse = mix(lightDiffuse, smColor * lightDiffuse, diffuseShodwMapmixRadio);
	
#ifdef FLOW_MAP
	gl_FragColor = mix(surfaceColor, mix(surfaceColor, flowColor, flowColor.a), flowRange) * lightDiffuse + lightSpecular + specularColor1;
#else
	gl_FragColor = surfaceColor * lightDiffuse + lightSpecular + specularColor1;
#endif

#ifdef EDGE_SHINE
	mediump float edgeIntensity = clamp(1.0 - abs(dot(CameraDirection, finalNormal)), 0.0, 1.0);
//	mediump float edgeMixValue  = pow(edgeIntensity, EdgeShinePower);
	gl_FragColor = mix(gl_FragColor, EdgeShineColor, pow(edgeIntensity, EdgeShinePower));
#endif

#ifdef COVERAGE_ALPHA
	mediump vec3 curPos = coveragePos - vec3(position.y-coveragePos.y, 0.0, position.y-coveragePos.y) * CameraDirection;
	curPos.y = position.y;
	mediump float delta = distance(position, curPos);
	if(delta <= radius)
	{
		gl_FragColor.a = min(pow(delta / radius, fallOff), 1.0) * gl_FragColor.a;
	}
#endif

#ifdef ENV_MAP
	vec3 eye = normalize(CameraPosition - position);
	vec3 reflectDir = reflect(-eye, finalNormal);
	vec3 envMask = texture2D(EnvMaskSampler, texCoord).xyz;
	vec3 envColor = computeEnvColor(reflectDir) * EnvStrength * envMask.r;
	
	// trick
	envColor *= lightDiffuse.xyz;

	gl_FragColor.xyz = gl_FragColor.xyz + envColor;
#endif

#ifdef EFFECT_COLOR
	gl_FragColor = ComputeEffectColor(gl_FragColor);
#endif

#ifndef TRANSPARENT
    #ifdef EMISSIVE
            gl_FragColor.rgb = gl_FragColor.rgb + surfaceColor.a * surfaceColor.rgb * 2.0;
    #endif
#endif


#ifdef RECEIVE_FOG
	gl_FragColor.xyz = mix(ofogColor.xyz, gl_FragColor.xyz, ofogColor.a);
	gl_FragColor.rgb = max(mix(gl_FragColor.rgb, varHeightFog.rgb, ComputeHeightFog(varHeightFog.a)), vec3(0.0));
#endif

#ifdef FILTER_COLOR
	mediump float gray = rgb_to_gray(gl_FragColor.r, gl_FragColor.g, gl_FragColor.b);
	mediump vec3 vec_gray = vec3(gray, gray, gray);
	gl_FragColor = vec4(mix(gl_FragColor.rgb, vec_gray, filterGray), gl_FragColor.a) * filterColor;	
#endif

#ifdef TRANSPARENT
	gl_FragColor.a = AlphaValue * surfaceColor.a;
#else
    #ifndef EMISSIVE
        gl_FragColor.a = surfaceColor.a;
    #endif
#endif

	
#ifdef EFFECT_COLOR
	gl_FragColor.a = gl_FragColor.a * uEffectColor.a;
#endif	

	gl_FragColor.rg = gl_FragColor.rg + vec2(HighLight);
	gl_FragColor = hdr2ldr(gl_FragColor);
}
