#version 100
precision mediump float;
#include <tonemapping.inc>
#include <hdr_ldr.inc>

#ifdef USE_FILTER_COLOR
uniform mediump vec4 filterColor;
uniform mediump float filterGray;
#endif

uniform mediump float CurrentTime;

uniform sampler2D NoiseSampler;
uniform sampler2D _BumpMap;
//uniform lowp	  samplerCube _Cube;
uniform sampler2D _Cube;
uniform sampler2D RefectSampler;
uniform sampler2D RefractionSampler;

uniform mediump float refect_degree;
uniform mediump float refraction_degree;

uniform mediump float noise_speed;
uniform mediump float noise_degree;

uniform mediump vec4 water_color;


varying mediump vec4 ofogColor;
varying mediump vec2 texCoord;
varying mediump vec2 texCoord1;
varying mediump vec2 texCoord2;
varying mediump vec3 texnormal;
varying mediump vec3 xlv_TEXCOORD0;
varying mediump vec4 xlv_TEXCOORD1;
//varying vec2 bumpuv0;
//varying vec2 bumpuv1;

void main(void)
{
	mediump vec2 texCoordOffset = texCoord;
	texCoordOffset.x += CurrentTime * 0.045 * noise_speed;
	texCoordOffset.y += CurrentTime * 0.045 * noise_speed;
	mediump vec4 NoiseColor = texture2D(NoiseSampler, texCoordOffset);

	texCoordOffset = texCoord;
	texCoordOffset.x += NoiseColor.x * 0.005 * noise_degree;
	texCoordOffset.y += NoiseColor.y * 0.005 * noise_degree;
	mediump vec4 RefectColor = texture2d_ldr2hdr(RefectSampler, texCoordOffset);  //反射颜色

	texCoordOffset = texCoord2;
	texCoordOffset.x += NoiseColor.x * 0.005 * noise_degree;
	texCoordOffset.y += NoiseColor.y * 0.005 * noise_degree;
	mediump vec4 RefractionColor = texture2d_ldr2hdr(RefractionSampler, texCoordOffset); //折射颜色


	//计算水的波动颜色
	mediump float _BumpStrength = 0.2767;
	mediump vec4  _FresnelParams = vec4(0.15,1.0,0.7,-0.18);

	  mediump vec4 baseColor_1;
	  mediump vec4 rtReflections_2;
	  mediump vec3 viewVector_3;
	  mediump vec3 worldNormal_4;
	  mediump vec4 coords_5;
	  coords_5 = xlv_TEXCOORD1;
	  mediump float bumpStrength_6;
	  bumpStrength_6 = _BumpStrength;
	  mediump vec4 bump_7;
	  lowp vec4 tmpvar_8;
	  tmpvar_8 = texture2D (_BumpMap, coords_5.xy);
	  lowp vec4 tmpvar_9;
	  tmpvar_9 = texture2D (_BumpMap, coords_5.zw);
	  mediump vec4 tmpvar_10;
	  tmpvar_10 = (tmpvar_8 + tmpvar_9);
	  bump_7.zw = tmpvar_10.zw;
	  bump_7.xy = (tmpvar_10.xy - vec2(1.0, 1.0));
	  mediump vec3 tmpvar_11;
	  tmpvar_11 = normalize((vec3(0.0, 1.0, 0.0) + (
		(bump_7.xxy * bumpStrength_6)
	   * vec3(1.0, 0.0, 1.0))));
	  worldNormal_4.y = tmpvar_11.y;
	  highp vec3 tmpvar_12;
	  tmpvar_12 = normalize(xlv_TEXCOORD0);
	  viewVector_3 = tmpvar_12;
	  mediump vec3 tmpvar_13;
	  tmpvar_13 = normalize((viewVector_3 - (2.0 * 
		(dot (tmpvar_11, viewVector_3) * tmpvar_11)
	  )));
	  lowp vec4 tmpvar_14;

	  //tmpvar_14 = textureCube (_Cube, tmpvar_13);
	  tmpvar_14 = texture2D (_Cube, tmpvar_13.xy);

	  rtReflections_2 = tmpvar_14;
	  highp vec2 tmpvar_15;
	  tmpvar_15 = (tmpvar_11.xz * _FresnelParams.x);
	  worldNormal_4.xz = tmpvar_15;
	  mediump float bias_16;
	  bias_16 = _FresnelParams.w;
	  mediump float power_17;
	  power_17 = _FresnelParams.z;
	  baseColor_1 = water_color;
	  baseColor_1.xyz = mix (baseColor_1, rtReflections_2, vec4(clamp (clamp (
		(bias_16 + ((1.0 - bias_16) * pow (clamp (
		  (1.0 - max (dot (-(viewVector_3), worldNormal_4), 0.0))
		, 0.0, 1.0), power_17)))
	  , 0.0, 1.0), 0.0, 1.0))).xyz;
	  baseColor_1.w = 1.0;

	

	mediump vec4 color_refect_water = baseColor_1 * RefectColor;
	mediump vec4 finalColor = mix(baseColor_1,color_refect_water,refect_degree);
	//mediump vec4 finalColor = baseColor_1;
	//折射相当于半透
	finalColor = mix(finalColor,RefractionColor,refraction_degree);

	gl_FragColor = vec4(mix(ofogColor.rgb, finalColor.rgb, ofogColor.a), finalColor.a);

#ifdef USE_FILTER_COLOR
	mediump float gray = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;
	mediump vec3 vec_gray = vec3(gray, gray, gray);
	gl_FragColor = vec4(mix(gl_FragColor.rgb, vec_gray, filterGray), gl_FragColor.a) * filterColor;	
#endif
	gl_FragColor = hdr2ldr(gl_FragColor);
}