#version 100
#include <hdr_ldr.inc>
uniform mediump vec3  CameraDirection;
uniform mediump float DiffuseIntensity;		// 0.0-1.0;
uniform mediump float SpecularIntensity;	// 0.0-16.f;
uniform mediump float SpecularPow;			// 2.0,4.0,8.0,16.0,32.0;
uniform mediump vec4  SpecularColor;
uniform mediump float CurrentTime;			// current time
uniform mediump vec4  CustomerColor;

uniform sampler2D Albedo;
uniform mediump float powShine;
uniform mediump float RimPorwe;
uniform mediump float RimIntensity;

uniform sampler2D lightSampler;

varying mediump vec2 texCoord;
varying mediump vec2 texCoord1;
varying mediump vec3 normal;
varying mediump vec3 position;

uniform sampler2D AOSampler;
uniform mediump vec4 LMUV;

#ifdef TRANSPARENT
	uniform mediump float AlphaValue;
#endif

#ifdef ALPHA_TEST
	uniform mediump float AlphaTestValue;
#endif

#ifdef COVERAGE_ALPHA
	uniform mediump vec3 coveragePos;
	uniform mediump float fallOff;
	uniform mediump float radius;
#endif

#define HSV_SUPPORT
#ifdef  HSV_SUPPORT
	// rgb to hsv
	mediump vec3 rgb2hsv(mediump vec3 c)
	{
		mediump vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
		mediump vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
		mediump vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);

		mediump float d = q.x - min(q.w, q.y);
		mediump float e = 1.0e-10;
		return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
	}
	
	// hsv to rgb
	mediump vec3 hsv2rgb(mediump vec3 c)
	{
		mediump vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
		mediump vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
		return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
	}

	// hsv hsv_modify
	mediump vec3 hsvAdjust(mediump vec3 hsv, mediump vec3 hsv_modify)
	{
		hsv.x = hsv.x + hsv_modify.r;
		hsv.y = clamp(hsv.y + hsv_modify.g, 0.0, 1.0);
		hsv.z = clamp(hsv.z + hsv_modify.b, 0.0, 1.0);
		return hsv;
	}
#endif

#ifdef SURFACE_COLOR_MASK
	uniform mediump vec3  HSVOffset1;
	uniform mediump vec3  HSVOffset2;
	uniform mediump vec3  HSVOffset3;
	uniform sampler2D 	  SurfaceColorMaskSampler;
#elif defined(SURFACE_COLOR)
	uniform mediump vec3  HSVOffset0;	
#endif

#ifdef NORMAL_MAP
	uniform sampler2D NormalSampler;
	varying mediump vec3 tangent;
#endif

#ifdef MASK_MAP
	uniform sampler2D MaskSampler;
#endif

#ifdef FLOW_MAP
	uniform mediump vec2 FlowDir;
	uniform sampler2D 	 FlowSampler;
#endif

#ifdef RECEIVE_SHADOW
	uniform mediump float ShadowShade;
	uniform sampler2D 	  SMSampler;
	varying mediump vec4  shadowmapSpace;
#endif

#define AMBIENT_LIGHT     1
#define DIRECTIONAL_LIGHT 2
#define POINT_LIGHT 	  3

uniform mediump int	 LightArrayInfo[8];
uniform mediump vec4 LightArrayData[16];

// calculate diffuse
void LightingPhase(
	out mediump vec4 oLightDiffuse, 
	out mediump vec4 oLightSpecular, 
	mediump vec3 inPixelWorldPosition, 
	mediump vec3 inPixelNormal, 
	mediump float inDiffuseIntensity, 
	mediump float inSpecularIntensity, 
	mediump float inSpecularPow)
{
	oLightDiffuse = vec4(0.0, 0.0, 0.0, 1.0);
	oLightSpecular= vec4(0.0, 0.0, 0.0, 1.0);
	
	for(int i=0; i<8; i++)
	{
		int lightType = LightArrayInfo[i];
		mediump vec4 LightColor = LightArrayData[i*2];
		mediump vec4 LightDir   = LightArrayData[i*2+1];
		if(lightType==AMBIENT_LIGHT)
		{
			oLightDiffuse.xyz += LightColor.xyz;
		}
		else if(lightType==DIRECTIONAL_LIGHT)
		{
			// Diffuse
			oLightDiffuse.xyz += (LightColor.xyz * max(dot(inPixelNormal, -LightDir.xyz), 0.0));
			
			// Specular
			mediump vec3 reflectNormal = normalize(reflect(LightDir.xyz, inPixelNormal));
			oLightSpecular.xyz += LightColor.xyz * pow(max(dot(reflectNormal, -CameraDirection), 0.0), inSpecularPow)* inSpecularIntensity;
		}
		else if(lightType==POINT_LIGHT)
		{
			mediump vec3  pixelToLight		  = LightDir.xyz-inPixelWorldPosition;
			mediump	float pixelToLightLen	  = length(pixelToLight);
			mediump float offsetDistance      = pixelToLightLen * LightDir.w;
			mediump float DistanceAttenuation = max(pow(1.0-clamp(offsetDistance, 0.0, 1.0), LightColor.w), 0.0);

			oLightDiffuse.xyz += LightColor.xyz * DistanceAttenuation * max(dot(inPixelNormal, pixelToLight/pixelToLightLen), 0.0);
			
			// Specular
			mediump vec3 reflectNormal = normalize(reflect(-pixelToLight, inPixelNormal));
			oLightSpecular.xyz += LightColor.rgb * DistanceAttenuation * pow(max(dot(reflectNormal, -CameraDirection), 0.0), inSpecularPow)* inSpecularIntensity;
		}
	}
	
	oLightDiffuse *= inDiffuseIntensity;
	oLightSpecular *= SpecularColor;
}

#ifdef EDGE_SHINE
	uniform mediump vec4  EdgeShineColor;
	uniform mediump float EdgeShinePower;
#endif

void RimColorPhase(out mediump vec4 rimColor,
					in mediump vec3 inPixelNormal,
					in mediump vec4 inSurfaceColor,
					in mediump float inRimPorwe,
					in mediump float inRimIntensity)
{
	
	for(int i=0; i<8; i++)
	{
		int lightType = LightArrayInfo[i];
		mediump vec4 LightColor = LightArrayData[i*2];
		mediump vec3 LightDir   = LightArrayData[i*2+1].xyz;
		if(lightType==DIRECTIONAL_LIGHT)
		{
			rimColor *= ((LightColor * pow((1.0 - max(0.0, dot(inPixelNormal, LightDir))), inRimPorwe)) * inRimIntensity);
		}
	}

	rimColor *= inSurfaceColor;
}

void main(void)
{
	// textureColor
    mediump vec4 surfaceColor = texture2D(Albedo, texCoord);
	
	mediump vec4 color111 = CustomerColor;
	
	mediump vec3 LMColor = texture2D(AOSampler, texCoord1).rgb * powShine;

	highp float lightCoord;
	mediump vec3 light0Dir = vec3(-0.9063078, 0.4226183, 0.0);
	lightCoord = (0.5 * dot (normal, normalize(-light0Dir))) + 0.5;
	mediump vec3 lightMapColor = texture2D(lightSampler, vec2(lightCoord)).rgb;

	mediump vec4 rimColor = vec4(1.0,1.0,1.0,1.0);
	RimColorPhase(rimColor, normal, surfaceColor, RimPorwe, RimIntensity);

//	mediump vec4 rimColor = (pow((1.0 - max(0.0, dot(normal, -light0Dir))), 2.0)) * surfaceColor;

	surfaceColor = vec4(surfaceColor.rgb * LMColor * lightMapColor * DiffuseIntensity, surfaceColor.a) + rimColor;
	
	mediump float specularIntensity = SpecularIntensity;
	
	// illumination
//	mediump vec4 lightDiffuse;
//	mediump vec4 lightSpecular;
//	LightingPhase(lightDiffuse, lightSpecular, position, finalNormal, DiffuseIntensity, specularIntensity, SpecularPow);
	
	gl_FragColor = surfaceColor;
//	gl_FragColor = vec4(normal, 1.0);
//	gl_FragColor = vec4(gl_FragColor.rgb * LMColor, gl_FragColor.a);
	gl_FragColor = hdr2ldr(gl_FragColor);
}