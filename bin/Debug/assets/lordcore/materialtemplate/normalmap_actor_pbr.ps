#version 100
precision highp float;
#include <tonemapping.inc>
#include <fog_ps.inc>
#include <hdr_ldr.inc>

#define saturate(x) clamp( x, 0.0, 1.0 )

uniform mediump vec4 ActorLitParam[3]; // 0.sunDir  1.sunColor 2.environmentColor
uniform float _Gloss;
uniform float _RimIntensity;
uniform float _RimPower;
uniform vec3 _RimDir;
uniform vec4 _RimColor;

#ifdef FLOW_MAP
	#include <flow_map.inc>
#endif

#ifdef RIME_LIGHT
	#include <rime_light.inc>
#endif

#ifdef ALPHA_TEST
	// 由于流光用的也是diffuse的a通道
	// 当使用alpha test的时候使用法线贴图的a通道
	// 如果这个时候没开法线贴图就直接关闭流光
	#ifndef NORMAL_MAP
		#undef FLOW_MAP
	#endif
	uniform float _AlphaTestValue;
#endif

uniform sampler2D Albedo;

varying vec2 texcoord0;
varying vec3 viewNormal;
varying vec3 viewDir;

varying vec4 ofogColor;

#ifdef DYNAMIC_SPECULAR
	uniform sampler2D specularSampler;
#endif

#ifdef HSV_COLOR_MASK
	#include <hsv_mask.inc>
#endif

#ifdef EFFECT_COLOR
	#include <effect_color.inc>
#endif

#ifdef ENV_MAP
#ifdef ENV_MAP_CUBE
	uniform samplerCube envSampler;
#else
	uniform sampler2D envSampler;
#endif
	uniform float _ENVStrength;

	vec3 computeEnvColor(vec3 en)
	{
	#ifdef ENV_MAP_CUBE
		vec3 r = textureCube(envSampler, en, 0.0).rgb;
	#else
		vec3 r = texture2D(envSampler, en.xy).rgb;
	#endif
		return r*r;
	}
#endif

#ifdef NORMAL_MAP
	uniform sampler2D normalSampler;
	varying mediump vec3 tangent;
	varying mediump vec3 binormal;

	vec3 SurfaceNormal(vec3 n)
	{
		vec3 T = tangent;
		vec3 B = binormal;
		vec3 N = gl_FrontFacing ? viewNormal : -viewNormal;

		vec3 r = 2.0 * n - vec3(1.0, 1.0, 1.0);
		return normalize(T*r.x + B*r.y + N*r.z);
	}
#endif

#ifdef SPECULAR_COLOR_MAP
	uniform sampler2D specularColorSampler;
	uniform mediump vec2 specularPower;
	uniform mediump float angle;
#endif

#ifdef SPRITE_ANIMATION
	uniform sampler2D SA_sampler;
	varying vec2  SA_inTexCoord;
#endif

float RougnessToSpecPower(float roughness)
{
	float n = 18.0 / log2((1.0-roughness)*0.968 + 0.03);
	n = max(n, -255.9370);
	return n*n;
}

float BlinnPhongDistribution( float HdotN, float specExp )
{
	float D = pow( HdotN, specExp ) * ( specExp + 1.0 ) / 2.0;
	return D;
}

vec3 rota(in vec3 normal, in float angle)
{
	float rad = radians(angle);
	float c = cos(rad);
	float s = sin(rad);

	mat3 rotaM = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, c, -s), vec3(0, s, c));

	return normalize(rotaM * normal);
}

void main ()
{
	vec4 albedoTexture = texture2d_linear(Albedo, texcoord0);
	
#ifdef HSV_COLOR_MASK
	hsv_color_calc(albedoTexture.xyz);
#endif
	
#ifdef ALPHA_TEST
	if(albedoTexture.a < _AlphaTestValue)
	{
		discard;
	}
#endif
	
	vec3 albedo = albedoTexture.rgb;
	vec3 lightColor = ActorLitParam[1].rgb;
	vec3 ambientcolor = ActorLitParam[2].rgb;
	
    vec4 specularMap = vec4(0.0);
#ifdef DYNAMIC_SPECULAR
	specularMap = texture2d_linear(specularSampler, texcoord0);
#endif
	
#ifdef NORMAL_MAP
	vec4 normalMapColor = texture2D(normalSampler, texcoord0);
	vec3 N = SurfaceNormal(normalMapColor.xyz);
#else
	vec3 N = normalize(viewNormal);
#endif

	vec3 V = normalize(viewDir);
	vec3 L = normalize(ActorLitParam[0].xyz);
	vec3 H = normalize(L + V);
	vec3 R = normalize(_RimDir);
 
	float LdotH = saturate(dot(L, H));
	float NdotL = saturate(dot(N, L));
	float NdotH = saturate(dot(N, H));

	
#if defined(GLOSS_MAP) && defined(DYNAMIC_SPECULAR)
	float gloss = specularMap.r * _Gloss;
#else
	float gloss = _Gloss + specularMap.r * 0.0001;
#endif

	vec3 envColor = vec3(0.00001);
	vec3 specularColor = vec3(0.00001);
	vec3 rimeColor = vec3(0.000001);
#ifdef ENV_MAP
	#if defined(DYNAMIC_SPECULAR)
	float envScale = specularMap.b;
	#else
	float envScale = 1.0;
	#endif
	vec3 envDir = reflect(V, N);
	envColor = computeEnvColor(envDir) * _ENVStrength * envScale;
#endif
	
	float specExp = RougnessToSpecPower(1.0 - gloss);
	float D = BlinnPhongDistribution(NdotH, specExp);

	float atten = 2.0;
	vec3 lightIntens = atten * lightColor;  
  
	vec3 ambiIntens = albedo * ambientcolor * 2.0;
	vec3 diffIntens = albedo * NdotL * lightIntens;
	float specBRDF = D / (4.0 * LdotH + 1e-4) * NdotL;
	vec3 specIntens = specBRDF * envColor;

#ifdef SPECULAR_COLOR_MAP
	vec4 textureColor = texture2d_linear(specularColorSampler, texcoord0);
	float rotaNdotV = saturate(dot(rota(N, angle), V));
	specularColor = saturate(textureColor.xyz * specularPower.x * pow( rotaNdotV, (specularPower.y * textureColor.w) ) * textureColor.w);
#endif

#ifdef RIME_LIGHT
	rimeColor = calcRimeColor(N, V);
#endif
	
    N = normalize(vec3(N.x, 0.5, N.z));
    float NdotR = saturate(dot(N, R));
	float NdotV = saturate(dot(N, V));
	vec3 rimIntens = pow(NdotR*(1.0 - NdotV), _RimPower) * _RimIntensity * _RimColor.rgb * albedo;

#ifdef SPRITE_ANIMATION
	vec4 sa_color = texture2d_linear(SA_sampler, SA_inTexCoord);
	//ambiIntens = mix(ambiIntens,sa_color.rgb,sa_color.a);
	ambiIntens += sa_color.xyz;
#endif
	
	vec3 result = ambiIntens + diffIntens + specIntens * 0.00001 + specularColor + rimIntens + rimeColor;

#ifdef FLOW_MAP
	vec4 flowColor = calcFlowMapColor(texcoord0);

	#ifdef ALPHA_TEST
		result = mixFlowColor(vec4(result, 1.0), flowColor, normalMapColor.a).xyz;
	#else
		result = mixFlowColor(vec4(result, 1.0), flowColor, albedoTexture.a).xyz;
	#endif
#endif
	
	gl_FragColor = vec4(result, 1.0);

	gl_FragColor.xyz = mix(ofogColor.xyz, gl_FragColor.xyz, ofogColor.a);
	gl_FragColor.rgb = mix(gl_FragColor.rgb, varHeightFog.rgb, ComputeHeightFog(varHeightFog.a));
	
#ifdef EFFECT_COLOR
    gl_FragColor = ComputeEffectColor(gl_FragColor);
#endif
	
	gl_FragColor = hdr2ldr(gl_FragColor);
}

