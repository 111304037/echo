#version 100
precision mediump float;

#include <tonemapping.inc>
#include <fog_ps.inc>

uniform mediump vec3  CameraDirection;
uniform mediump vec3  CameraPosition;
uniform mediump float CurrentTime;			// current time

uniform sampler2D Albedo;
uniform mediump vec4 pureColor;

#ifdef DYNAMIC_SPECULAR
	uniform sampler2D 	  SpecularSampler;
	uniform mediump float SpecularIntensity;	// 0.0-16.f;
	uniform mediump float SpecularPow;			// 2.0,4.0,8.0,16.0,32.0;
#endif

varying mediump vec2 texCoord;
varying mediump vec3 normal;
varying mediump vec3 position;

#ifdef USE_LIGHTMAP
	uniform sampler2D LMSampler;
	uniform mediump vec4 LMUV;
	uniform mediump vec3 LMScale;
	varying mediump vec2 texCoord1;
#endif

#ifdef RECEIVE_FOG
	varying vec4 ofogColor;
#endif

#ifdef ALPHA_TEST
	uniform mediump float AlphaTestValue;
#endif

#ifdef COVERAGE_ALPHA
	uniform mediump vec3 coveragePos;
	uniform mediump float fallOff;
	uniform mediump float radius;
#endif

#ifdef ENV_MAP
	uniform sampler2D EnvSampler;
	uniform sampler2D EnvMaskSampler;
	uniform mediump float EnvStrength;
#endif

#define HSV_SUPPORT
#ifdef  HSV_SUPPORT
	#include <hsv.inc>
#endif

#ifdef SURFACE_COLOR_MASK
	uniform mediump vec3  HSVOffset1;
	uniform mediump vec3  HSVOffset2;
	uniform mediump vec3  HSVOffset3;
	uniform sampler2D 	  SurfaceColorMaskSampler;
#elif defined(SURFACE_COLOR)
	uniform mediump vec3  HSVOffset0;	
#endif

#ifdef NORMAL_MAP
	uniform sampler2D NormalSampler;
	varying mediump vec3 tangent;
	varying mediump vec3 binormal;
#endif

#ifdef FLOW_MAP
	uniform mediump vec2 FlowDir;
	uniform sampler2D 	 FlowSampler;
#endif

#define AMBIENT_LIGHT     1
#define DIRECTIONAL_LIGHT 2
#define POINT_LIGHT 	  3

uniform mediump int	 LightArrayInfo[8];
uniform mediump vec4 LightArrayData[16];

#ifdef FILTER_COLOR
uniform mediump vec4 filterColor;
uniform mediump float filterGray;
#endif

// calculate diffuse
void LightingPhase( out mediump vec4 oLightSpecular, mediump vec4 iSpecularColor, mediump vec3 inPixelWorldPosition, mediump vec3 inPixelNormal, mediump float inSpecularIntensity, mediump float inSpecularPow)
{
	oLightSpecular= vec4( 0.0, 0.0, 0.0, 1.0);
	
	for( int i=0; i<2; i++)
	{
		int lightType = LightArrayInfo[i];
		mediump vec4 LightColor = LightArrayData[i*2];
		mediump vec4 LightDir   = LightArrayData[i*2+1];
		if( lightType==DIRECTIONAL_LIGHT)
		{
			// Specular
			mediump vec3 reflectNormal = normalize( reflect( LightDir.xyz, inPixelNormal));
			oLightSpecular.xyz += LightColor.xyz * pow( max( dot(reflectNormal, -CameraDirection), 0.0), inSpecularPow)* inSpecularIntensity;
		}
		else if( lightType==POINT_LIGHT)
		{
			mediump vec3  pixelToLight		  = LightDir.xyz-inPixelWorldPosition;
			mediump	float pixelToLightLen	  = length( pixelToLight);
			mediump float offsetDistance      = pixelToLightLen * LightDir.w;
			mediump float DistanceAttenuation = max( pow( 1.0-clamp( offsetDistance, 0.0, 1.0), LightColor.w), 0.0);
			
			// Specular
			mediump vec3 reflectNormal = normalize( reflect( -pixelToLight, inPixelNormal));
			oLightSpecular.xyz += LightColor.rgb  * DistanceAttenuation * pow( max( dot(reflectNormal, -CameraDirection), 0.0), inSpecularPow)* inSpecularIntensity;
		}
	}
	
	oLightSpecular *= iSpecularColor;
}

#ifdef EDGE_SHINE
	uniform mediump vec4  EdgeShineColor;
	uniform mediump float EdgeShinePower;
#endif

mediump vec3 SurfaceNormal(mediump vec3 n, mediump vec3 vTangent, mediump vec3 vBinormal)
{
   mediump vec3 T = vTangent;
   mediump vec3 B = vBinormal;
   mediump vec3 N = gl_FrontFacing ? normal : -normal;
   
   N = normalize(N);
   T -= dot(T, N)*N;
   T = normalize(T);
   B = (B - dot(B, N)*N) - dot(B, T)*T;
   B = normalize(B);

   n = 2.0*n - vec3(1.0);
   return normalize(T*n.x + B*n.y + N*n.z);
}

#ifdef ENV_MAP
vec3 computeEnvColor(vec3 en)
{
	en /= dot(vec3(1.0), abs(en));
	vec2 eH = abs(en.zx) - vec2(1.0, 1.0);
	vec2 eI = vec2(en.x < 0.0 ? eH.x : -eH.x, en.z < 0.0 ? eH.y : -eH.y);
	vec2 eJ = (en.y < 0.0) ? eI : en.xz; 
	eJ = vec2(0.5*(254.0 / 256.0), 0.125*0.5*(254.0 / 256.0))*eJ + vec2(0.5, 0.125*0.5);
	vec2 eL = vec2(eJ.x,eJ.y*8.0);
	vec4 eM = texture2D(EnvSampler, eL);
	vec3 r = eM.xyz;
	return r*r;
}
#endif

void main(void)
{
	// textureColor
	mediump vec4 surfaceColor = texture2d_linear(Albedo, texCoord);
	
#ifdef ALPHA_TEST
	// alpha test
	if(surfaceColor.w < AlphaTestValue)
	{
		discard;
	}
#endif
	
#ifdef SURFACE_COLOR_MASK
	mediump vec3 surfaceColorMask = texture2D(SurfaceColorMaskSampler, texCoord).xyz;
	
	mediump vec3 hsvSurfaceColor = hsvAdjust(rgb2hsv(surfaceColor.xyz), HSVOffset1 * surfaceColorMask.x + HSVOffset2*surfaceColorMask.y + HSVOffset3*surfaceColorMask.z);
	surfaceColor.xyz = hsv2rgb(hsvSurfaceColor.xyz);
	
#elif defined(SURFACE_COLOR)
	mediump vec3 hsvSurfaceColor = hsvAdjust(rgb2hsv(surfaceColor.xyz), HSVOffset0);
	surfaceColor.xyz = hsv2rgb(hsvSurfaceColor.xyz);
#endif
	
	mediump vec3 finalNormal = normal;
	
#ifdef NORMAL_MAP
	// normal map
	// mediump vec3 texnormal = 2.0 * texture2D(NormalSampler, texCoord).xyz - vec3(1.0);
	// mediump vec3 binormal = normalize(cross(normal, tangent));
	// finalNormal = vec3(dot(vec3(tangent.x, binormal.x, normal.x), texnormal), dot(vec3(tangent.y, binormal.y, normal.y), texnormal), dot(vec3(tangent.z, binormal.z, normal.z), texnormal));

	finalNormal = SurfaceNormal(texture2D(NormalSampler, texCoord).xyz, tangent, binormal);
#endif

	
#ifdef FLOW_MAP
	mediump float flowRange = 1.0;
	mediump vec4  flowColor = texture2d_linear(FlowSampler, texCoord + FlowDir * CurrentTime * 0.001);
#endif
	
#ifdef DYNAMIC_SPECULAR
	// illumination
	mediump float specularIntensity = SpecularIntensity;
	mediump vec4 lightDiffuse  = vec4( 0.0, 0.0, 0.0, 1.0);
	mediump vec4 lightSpecular = vec4( 0.0, 0.0, 0.0, 1.0);
	mediump vec4 specularColor = texture2d_linear(SpecularSampler, texCoord);
	LightingPhase(lightSpecular, specularColor, position, finalNormal, specularIntensity, SpecularPow);
#else
	mediump vec4 lightDiffuse  = vec4( 1.0, 1.0, 1.0, 1.0);
	mediump vec4 lightSpecular = vec4( 0.0, 0.0, 0.0, 0.0);;
#endif

#ifdef USE_LIGHTMAP
	mediump vec3 LMColor = texture2d_linear(LMSampler, texCoord1.xy*LMUV.zw+LMUV.xy).rgb * LMScale;

	lightDiffuse.xyz = lightDiffuse.xyz * 0.0 + LMColor;
#endif
	
#ifdef FLOW_MAP
	gl_FragColor = mix(surfaceColor, mix(surfaceColor, flowColor, flowColor.a), flowRange) * lightDiffuse + lightSpecular;
#else
	gl_FragColor = pureColor;// * lightDiffuse + lightSpecular;
#endif

#ifdef EDGE_SHINE
	mediump float edgeIntensity = clamp(1.0 - abs(dot(CameraDirection, finalNormal)), 0.0, 1.0);
//	mediump float edgeMixValue  = pow(edgeIntensity, EdgeShinePower);
	gl_FragColor = mix(gl_FragColor, EdgeShineColor, pow(edgeIntensity, EdgeShinePower));
#endif

#ifdef COVERAGE_ALPHA
	mediump vec3 curPos = coveragePos - vec3(position.y-coveragePos.y, 0.0, position.y-coveragePos.y) * CameraDirection;
	curPos.y = position.y;
	mediump float delta = distance(position, curPos);
	if(delta <= radius)
	{
		gl_FragColor.a = min(pow(delta / radius, fallOff), 1.0) * gl_FragColor.a;
	}
#endif

#ifdef ENV_MAP
	vec3 eye = normalize(CameraPosition - position);
	vec3 reflectDir = reflect(-eye, finalNormal);
	vec3 envMask = texture2D(EnvMaskSampler, texCoord).xyz;
	vec3 envColor = computeEnvColor(reflectDir) * EnvStrength * envMask.r;
	
	// trick
	envColor *= lightDiffuse.xyz;

	gl_FragColor.xyz = gl_FragColor.xyz + envColor;
#endif

#ifdef RECEIVE_FOG
	gl_FragColor.xyz = mix(ofogColor.xyz, gl_FragColor.xyz, ofogColor.a);
	gl_FragColor.rgb = mix(gl_FragColor.rgb, varHeightFog.rgb, ComputeHeightFog(varHeightFog.a));
#endif

#ifdef FILTER_COLOR
	mediump float gray = rgb_to_gray(gl_FragColor.r, gl_FragColor.g, gl_FragColor.b);
	mediump vec3 vec_gray = vec3(gray, gray, gray);
	gl_FragColor = vec4(mix(gl_FragColor.rgb, vec_gray, filterGray), gl_FragColor.a) * filterColor;	
#endif
}
